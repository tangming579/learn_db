### 认识事务

事务是访问并更新数据库中各种数据项的一个程序执行单元，在事务的操作中，要么都做修改，要么都不做修改，这就是事务的目的。

事务的ACID：

- 原子性（automatic）：由 redo log 实现 
- 一致性（consistent）：由 undo log 实现
- 隔离性（isolation）：由锁来实现
- 持久性（durability）：由 redo log 实现 

### 事务的实现

当执行 Insert、Update、Delete 动作时数据库不会真的去数据文件中执行 I/O 操作，而是分了两部分：

- 修改内存中的数据（数据库称为 Buffer）

- 记录 Redo Undo 日志

只有当 Buffer 达到刷新条件（比如脏数据达到一定比例）才会对数据文件进行操作。数据库这么设计是出于性能考虑，因为**读写数据文件是一次随机 I/O会降低系统性能；虽然 Redo Undo 也会写文件，但它是顺序写入**，性能比较高。这种顺序写入一般采用 LSM （Log Structured Merge Trees）算法，因为数据并没有真正的写入数据文件，所以当数据库系统崩溃后（比如断电、系统重启、介质错误），数据库系统会利用Redo、Undo 恢复数据。

#### redo（重做）

重做日志用来实现事务的持久性，由两部分组成：

- 内存中的重做日志缓冲（redo log buffer），其易丢失。

- 重做日志文件（redo log file），其是持久性的

##### redo 如果保证持久性

通过 Force Log at Commit 机制实现事务的持久性。即当事务提交时，必须先将该事物的所有日志写入到重做日志文件进行持久化，待事务提交完成才算操作完成

##### redo记录了什么
redo即redo日志，记录数据库变化的日志（区别我们常见的简单的文本日志，redo日志里面记录的都是数据，表数据啊等等压缩处理，但也很大）。
只要你修改了数据块那么就会记录redo信息，当然nologging除外。
修改的数据块包括：表所在数据块（表数据块），索引所在数据块（索引数据块），以及undo段所在数据块（undo数据块）

#### undo（撤销）

undo存放在数据库内部的一个特殊段（segment）中，这个段称为 undo段（undo segment）。undo 段位于共享表空间中。

##### undo 的作用

- 事务回滚

  undo日志，只将数据库逻辑地恢复到原来的样子，在回滚的时候，它实际上是做的相反的工作，比如一条INSERT ，对应一条 DELETE，对于每个UPDATE,对应一条相反的 UPDATE,将修改前的行放回去。undo日志用于事务的回滚操作进而保障了事务的原子性。

- MVCC

  当用户读取一行记录时，若该记录已被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以此实现非锁定读取。

--A更改未提交，B查询的话，数据肯定为历史数据，这个历史数据就是来源于UNDO段，

--A更改未提交，需要回滚rollback，回滚rollback的数据也来至于UNDO段。

结论：为了并发时读一致性成功，那么DML操作，肯定先写UNDO段。