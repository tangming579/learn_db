## Redis

### 简介

Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。

Redis 与其他 key - value 缓存产品有以下三个特点：

- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
- Redis支持数据的备份，即master-slave模式的数据备份。

### .Net下的使用

.Net 下对Redis操作主要有两种方式：ServiceStack.Redis 与 StackExchange.Reids

1. ServiceStack.Redis：功能强大，速度快。但引用类库较多，4.0以上版本有每小时调用6000次的限制
2. StackExchange.Redis：免费开源，速度稍慢一些，没有太多依赖项，只需引用一个dll

### 数据类型

| 结构类型         | 结构存储的值                                                 | 结构的读写能力                                               |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| String           | 可以是字符串、整数或者浮点数                                 | 对整个字符串或者字符串的其中一部分执行操作；对整数和浮点数执行自增（increment）或者自减（decrement）操作 |
| List             | 一个链表，链表上的每个节点都包含了一个字符串                 | 从脸部的两端推入或者弹出元素；根据偏移量对链表进行修剪（trim）；读取单个或者多个元素；根据值查找或者移除元素 |
| Set              | 包含字符串的无序收集器（unordered collection），并且被包含的每个字符串都是独一无二、各不相同的 | 添加、获取、移除单个元素；检查一个元素是否存在于集合中；计算交集、并集、差集；从集合里面随机获取元素 |
| Hash             | 包含键值对的无序散列表                                       | 添加、获取、移除单个键值对；获取所有键值对                   |
| ZSet（有序集合） | 字符串成员（member）与浮点数分值（score）之间的有序映射，元素的排列顺序由分值的大小决定 | 添加、获取、删除单个元素；根据分值范围（range）或者成员来获取元素 |

#### 字符串

| 命令 | 行为                                               | 举例            | 说明                     |
| ---- | -------------------------------------------------- | --------------- | ------------------------ |
| get  | 获取存储的给定健中的值                             | set hello world | 将键hello的值设置为world |
| set  | 设置存储的给定健中的值                             | get hello       |                          |
| del  | 删除存储在给定健中的值（这个命令可以用于所有类型） | del hello       |                          |

#### 列表

| 命令   | 行为                                     | 举例                 | 说明                                       |
| ------ | ---------------------------------------- | -------------------- | ------------------------------------------ |
| rpush  | 将给定值推入列表右端                     | rpush list-key item  | 向列表推入新元素，该命令返回列表长度       |
| lrange | 获取列表的给定范围上的所有值             | lrange list-key 0 -1 | 0表示第一个元素，-1表示倒数第一个元素      |
| lindex | 获取列表的给定位置上的单个元素           | lindex list-key 1    | 列出第二个元素                             |
| lpop   | 从列表的左端弹出一个值，并返回被弹出的值 | lpop list-key        | 弹出一个元素，被弹出的元素将不再存在于列表 |

#### 集合

Redis的集合和列表都可以存储多个字符串，他们之间的不同在于，列表可以存储多个相同的字符串，而集合则通过使用散列表来保证自助存储的字符串都各不相同

| 命令      | 行为                                       | 举例                     |
| --------- | ------------------------------------------ | ------------------------ |
| sadd      | 将给定元素添加到集合                       | sadd set-key item2       |
| smembers  | 返回集合包含的所有元素                     | smembers set-key         |
| sismember | 检查给定元素是否存在于集合中               | sismemeber set-key item2 |
| srem      | 如果给定的元素存在于集合中，那么移除该元素 | srem set-key item2       |

#### 散列

| 命令    | 行为                                     | 举例                          |
| ------- | ---------------------------------------- | ----------------------------- |
| hset    | 在散列里面关联起给定的键值对             | hset hash-key sub-key1 value1 |
| hget    | 获取指定的散列键的值                     | hget hash-key sub-key1        |
| hgetall | 获取散列包含的所有键值对                 | hgetall hash-key              |
| hdel    | 如果给定键存在于散列里面，那么移除这个键 | hdel hash-key sub-key2        |

#### 有序集合

有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member），每个成员都是各不相同的；二有序集合的值被称为分值（score），分值必须为浮点数

| 命令          | 行为                                                       | 举例                                    |
| ------------- | ---------------------------------------------------------- | --------------------------------------- |
| zadd          | 将一个带有给定分值的成员添加到有序集合里面                 | zadd zset-key 728 member1               |
| zrange        | 根据元素在有序排列中所处的位置，从有序集合里面获取多个元素 | zrange zset-key 0 -1                    |
| zrangebyscore | 获取有序集合在给定分值范围内的所有元素                     | zrangebyscore zset-key 0 800 withscores |
| zrem          | 如果给定成员存在于有序集合，那么移除这个成员               | zrem zset-key member1                   |

### 并发

#### 缓存穿透
缓存穿透本质上是查询一个缓存和数据库中都不存在的key值，Redis的缓存层无法命中，导致请求再次指向执行数据库层的情况。
由于是查询到值不存在（当然也不存在于Redis缓存中），导致请求总是“穿透”Redis发往数据库层，因此缓存层失去了“保护”关系数据库层的意义。
解决方案：
布隆过滤器是一个比较好的选择，参考：https://www.cnblogs.com/wy123/p/11571215.html

#### 缓存击穿
缓存穿透本质上是高并发地请求一个缓存中不存在，但是数据库中可能存在的key值，因此请求指向数据库，导致数据库端承担大量的请求压力的情况。
解决方案：
这种场景可以从代码逻辑层面优化，从缓存中查询不到数据，再次将请求转向数据库中的时候，锁定该key，获取到该key之后，将该key写入缓存

#### 缓存雪崩
某些原因，比如:
1,Redis实例（主从，集群，哨兵等等）故障。
2,Redis中的key由于过期时间已到，自动过期。
3,由于Redis内存策略导致（maxmemory，maxmemory-policy配置）某些key失效（过期，被清理出缓存等）。
如果此时出现高并发的请求出现，这些请求会全部指向数据库层，缓存层失去了对数据库层的保护，导致数据库承担绝大压力的情况。
解决方案：
1，Redis层的高可用，保证缓存层可以有效地保护数据库层
2，从Redis配置（内存管理策略maxmemory，maxmemory-policy）以及结合业务，避免某些潜在的热点key值过期
3，应用程序端限流，或者通过队列的方式等削峰的方式来保护后端数据库

### 过期策略

过期策略通常有一下三种：

- 定时删除：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。

- 惰性删除：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。

- 定期删除：每隔一段时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的折中方案。

  定期删除可以通过：

  - 第一、配置redis.conf 的hz选项，默认为10 （即1秒执行10次，100ms一次，随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。） 
  - 第二、配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略（内存淘汰机制）

Redis中同时使用了惰性过期和定期过期两种过期策略。

### 持久化

#### RDB持久化

RDB持久化是将某个时间点上Redis中的数据保存到一个RDB文件中，基于RDB持久化的上述性质，所以RDB持久化也叫做快照持久化。该文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时Redis中的数据。

Redis提供了2个命令来创建RDB文件：

- SAVE：会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求
- BGSAVE（常用）：会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求

自动触发 RDB 的默认配置如下所示:

```
save 900 1 # 表示900 秒内如果至少有 1 个 key 的值变化，则触发RDB
save 300 10 # 表示300 秒内如果至少有 10 个 key 的值变化，则触发RDB
save 60 10000 # 表示60 秒内如果至少有 10000 个 key 的值变化，则触发RDB
```

> 为什么 Redis 使用子进程而不是线程来进行后台 RDB 持久化呢？主要是出于Redis性能的考虑，我们知道Redis对客户端响应请求的工作模型是单进程和单线程的，如果在主进程内启动一个线程，这样会造成对数据的竞争条件。所以为了避免使用锁降低性能，Redis选择启动新的子进程，独立拥有一份父进程的内存拷贝，以此为基础执行RDB持久化。

#### AOF持久化

AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库数据的，当AOF持久化功能处于打开状态时，Redis服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的AOF缓冲区的末尾，然后Redis服务器会根据配置文件中appendfsync选项的值来决定何时将AOF缓冲区中的内容写入和同步到AOF文件里。

在Redis的配置文件中存在三种同步方式，它们分别是：

- appendfsync always   #每次有数据修改发生时都会写入AOF文件。

- appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。

- appendfsync no     #从不同步。高效但是数据不会被持久化。

#### 区别

- 实现方式

RDB持久化是通过将某个时间点Redis服务器存储的数据保存到RDB文件中来实现持久化的。

AOF持久化是通过将Redis服务器执行的所有写命令保存到AOF文件中来实现持久化的。

- 文件体积

由上述实现方式可知，RDB持久化记录的是结果，AOF持久化记录的是过程，所以AOF持久化生成的AOF文件会有体积越来越大的问题，Redis提供了AOF重写功能来减小AOF文件体积。

- 安全性

AOF持久化的安全性要比RDB持久化的安全性高，即如果发生机器故障，AOF持久化要比RDB持久化丢失的数据要少。

因为RDB持久化会丢失上次RDB持久化后写入的数据，而AOF持久化最多丢失1s之内写入的数据（使用默认everysec配置的话）。

- 优先级

由于上述的安全性问题，如果Redis服务器开启了AOF持久化功能，Redis服务器在启动时会使用AOF文件来还原数据，如果Redis服务器没有开启AOF持久化功能，Redis服务器在启动时会使用RDB文件来还原数据，所以AOF文件的优先级比RDB文件的优先级高。

### 分布式集群部署

redis的多机数据库实现，主要分为以下三种：

1. Redis哨兵（Sentinel）
2. Redis复制（主从）
3. Redis集群

#### Redis复制（主从）

当开启主从模式的时候，他的具体工作机制如下：

1. 当slave启动后会向master发送`SYNC`命令，master节后到从数据库的命令后通过`bgsave`保存快照（**「RDB持久化」**），并且期间的执行的些命令会被缓存起来。
2. 然后master会将保存的快照发送给slave，并且继续缓存期间的写命令。
3. slave收到主数据库发送过来的快照就会加载到自己的数据库中。
4. 最后master讲缓存的命令同步给slave，slave收到命令后执行一遍，这样master与slave数据就保持一致了。

优点：

- 解决了单机版并发量大，导致请求延迟或者redis宕机服务停止的问题。
- 实现读写分离
- 一定程度上提高了系统的可用性和性能，是实现哨兵和集群的基础

缺点：

- 数据的一致性问题
- 主从模式不具备自动容错和恢复的功能

#### 哨兵（Sentinel）模式

为了解决Redis的主从复制的不支持高可用性能，Redis实现了Sentinel哨兵机制解决方案。主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。

哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。

这里的哨兵有两个作用

- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
- 当哨兵监测到master宕机，会自动将slave切换成master，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机。

然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。

#### 集群（Cluster）

哨兵解决主从不能自动故障恢复的问题，但是同时也存在难以扩容以及单机存储、读写能力受限的问题，并且集群之前都是一台redis都是全量的数据，这样所有的redis都冗余一份，就会大大消耗内存空间。

集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。一个Redis集群通常由多个节点组成；最初，每个节点都是独立的，需要将独立的节点连接起来才能形成可工作的集群。

在Redis集群中采用的使虚拟槽分区算法，会把redis集群分成16384 个槽（0 -16383）。

Cluster Nodes命令和Cluster Meet命令，添加和连接节点形成集群。

